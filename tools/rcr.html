<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random CIDR Range Generator | ipgoy.im</title>
    <link rel="stylesheet" href="https://ipgoy.im/styles.css">
    <style>
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .result-box {
            margin-top: 20px;
            display: none;
        }
        .error-box {
            margin-top: 20px;
            display: none;
            background-color: var(--active-link);
            color: white;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="text"] {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
        }
        .footer {
            margin-top: 30px;
            text-align: center;
            font-size: 12px;
        }
        .site-header {
            text-align: center;
            margin-bottom: 20px;
        }
        .site-logo {
            font-family: Arial, Helvetica, sans-serif;
            font-size: 24px;
            font-weight: bold;
            color: var(--header-bg);
            margin-bottom: 10px;
        }
        .ip-version-toggle {
            margin: 10px 0;
            text-align: center;
        }
        .ip-version-toggle button {
            margin: 0 5px;
        }
        .active-version {
            background-color: var(--header-bg) !important;
            color: var(--header-text) !important;
        }
    </style>
</head>
<body>
    <div class="navbar">
        <a href="https://ipgoy.im">Home</a>
    </div>

    <div class="container">
        <div class="site-header">
            <div class="site-logo">ipgoy.im</div>
            <h1>Random CIDR Range Generator</h1>
        </div>
        
        <div class="ip-version-toggle">
            <button id="ipv4-btn" class="active-version">IPv4</button>
            <button id="ipv6-btn">IPv6</button>
        </div>
        
        <div class="box" id="ipv4-box">
            <div class="box-title">IPv4 Generator</div>
            <div class="form-group">
                <label for="cidr">IPv4 CIDR Range (e.g., 5.62.62.0/23):</label>
                <input type="text" id="cidr" placeholder="Enter IPv4 CIDR range...">
            </div>
            <button id="generate-btn">Generate Random IP</button>
        </div>

        <div class="box" id="ipv6-box" style="display: none;">
            <div class="box-title">IPv6 Generator</div>
            <div class="form-group">
                <label for="cidr6">IPv6 CIDR Range (e.g., 2001:db8::/32):</label>
                <input type="text" id="cidr6" placeholder="Enter IPv6 CIDR range...">
            </div>
            <button id="generate-btn6">Generate Random IP</button>
        </div>

        <div id="error-box" class="box error-box">
            <div class="box-title">Error</div>
            <div id="error-message"></div>
        </div>

        <div id="result-box" class="box result-box">
            <div class="box-title">Random IP from CIDR Range</div>
            <table>
                <tr>
                    <td><strong>CIDR Range</strong></td>
                    <td id="cidr-display"></td>
                </tr>
                <tr>
                    <td><strong>Random IP</strong></td>
                    <td id="random-ip"></td>
                </tr>
                <tr>
                    <td colspan="2"><strong>Network Info</strong></td>
                </tr>
                <tr>
                    <td>Total IPs:</td>
                    <td id="total-ips"></td>
                </tr>
                <tr>
                    <td>Netmask:</td>
                    <td id="netmask"></td>
                </tr>
                <tr>
                    <td>Usable Range:</td>
                    <td id="usable-range"></td>
                </tr>
            </table>
        </div>

        <div class="footer">
            Made by rec :3, Hosted by xkya (nyanc4tt) | <a href="https://ipgoy.im">ipgoy.im</a>
        </div>
    </div>

    <script>
        // IP version toggle
        document.getElementById('ipv4-btn').addEventListener('click', () => {
            document.getElementById('ipv4-box').style.display = 'block';
            document.getElementById('ipv6-box').style.display = 'none';
            document.getElementById('ipv4-btn').classList.add('active-version');
            document.getElementById('ipv6-btn').classList.remove('active-version');
        });

        document.getElementById('ipv6-btn').addEventListener('click', () => {
            document.getElementById('ipv4-box').style.display = 'none';
            document.getElementById('ipv6-box').style.display = 'block';
            document.getElementById('ipv6-btn').classList.add('active-version');
            document.getElementById('ipv4-btn').classList.remove('active-version');
        });

        // IPv4 Generator
        document.getElementById('generate-btn').addEventListener('click', () => {
            const cidr = document.getElementById('cidr').value.trim();
            generateRandomIP(cidr, 'v4');
        });

        // IPv6 Generator
        document.getElementById('generate-btn6').addEventListener('click', () => {
            const cidr = document.getElementById('cidr6').value.trim();
            generateRandomIP(cidr, 'v6');
        });

        function generateRandomIP(cidr, version) {
            const errorBox = document.getElementById('error-box');
            const resultBox = document.getElementById('result-box');
            
            // Hide both boxes initially
            errorBox.style.display = 'none';
            resultBox.style.display = 'none';

            if (!cidr) {
                showError(`Please provide a CIDR range. Example: ${version === 'v4' ? '5.62.62.0/23' : '2001:db8::/32'}`);
                return;
            }

            try {
                let networkInfo, randomIP;
                
                if (version === 'v4') {
                    networkInfo = parseIPv4CIDR(cidr);
                    randomIP = getRandomIPv4(networkInfo);
                } else {
                    networkInfo = parseIPv6CIDR(cidr);
                    randomIP = getRandomIPv6(networkInfo);
                }
                
                // Display results
                document.getElementById('cidr-display').textContent = cidr;
                document.getElementById('random-ip').textContent = randomIP;
                document.getElementById('total-ips').textContent = formatLargeNumber(networkInfo.numAddresses);
                document.getElementById('netmask').textContent = networkInfo.netmask;
                document.getElementById('usable-range').textContent = `${networkInfo.firstUsable} - ${networkInfo.lastUsable}`;
                
                resultBox.style.display = 'block';
            } catch (error) {
                showError(error.message);
            }
        }

        // IPv4 Functions
        function parseIPv4CIDR(cidr) {
            const cidrRegex = /^(\d{1,3}\.){3}\d{1,3}\/\d{1,2}$/;
            if (!cidrRegex.test(cidr)) {
                throw new Error("Invalid IPv4 CIDR format. Example: 5.62.62.0/23");
            }

            const [ip, prefix] = cidr.split('/');
            const prefixLength = parseInt(prefix);
            
            if (prefixLength < 0 || prefixLength > 32) {
                throw new Error("Prefix length must be between 0 and 32");
            }

            const octets = ip.split('.');
            if (octets.length !== 4) {
                throw new Error("Invalid IPv4 address");
            }

            for (const octet of octets) {
                const num = parseInt(octet);
                if (num < 0 || num > 255) {
                    throw new Error("IPv4 octets must be between 0 and 255");
                }
            }

            const netmask = calculateIPv4Netmask(prefixLength);
            const numAddresses = Math.pow(2, 32 - prefixLength);
            const networkAddress = calculateIPv4NetworkAddress(ip, prefixLength);
            const broadcastAddress = calculateIPv4BroadcastAddress(networkAddress, prefixLength);
            
            const firstUsable = incrementIPv4(networkAddress);
            const lastUsable = decrementIPv4(broadcastAddress);

            return {
                netmask,
                numAddresses,
                firstUsable,
                lastUsable,
                networkAddress,
                broadcastAddress
            };
        }

        function calculateIPv4Netmask(prefixLength) {
            let mask = 0xffffffff << (32 - prefixLength);
            return [
                (mask >>> 24) & 0xff,
                (mask >>> 16) & 0xff,
                (mask >>> 8) & 0xff,
                mask & 0xff
            ].join('.');
        }

        function calculateIPv4NetworkAddress(ip, prefixLength) {
            const ipInt = ipv4ToInt(ip);
            const mask = 0xffffffff << (32 - prefixLength);
            return intToIPv4(ipInt & mask);
        }

        function calculateIPv4BroadcastAddress(networkAddress, prefixLength) {
            const networkInt = ipv4ToInt(networkAddress);
            const hostBits = 32 - prefixLength;
            return intToIPv4(networkInt | ((1 << hostBits) - 1));
        }

        function getRandomIPv4(networkInfo) {
            const networkInt = ipv4ToInt(networkInfo.networkAddress);
            const broadcastInt = ipv4ToInt(networkInfo.broadcastAddress);
            
            const randomInt = Math.floor(Math.random() * (broadcastInt - networkInt - 1)) + networkInt + 1;
            return intToIPv4(randomInt);
        }

        function ipv4ToInt(ip) {
            return ip.split('.').reduce((acc, octet) => (acc << 8) + parseInt(octet), 0) >>> 0;
        }

        function intToIPv4(int) {
            return [
                (int >>> 24) & 0xff,
                (int >>> 16) & 0xff,
                (int >>> 8) & 0xff,
                int & 0xff
            ].join('.');
        }

        function incrementIPv4(ip) {
            const int = ipv4ToInt(ip);
            return intToIPv4(int + 1);
        }

        function decrementIPv4(ip) {
            const int = ipv4ToInt(ip);
            return intToIPv4(int - 1);
        }

        // IPv6 Functions
        function parseIPv6CIDR(cidr) {
            const cidrRegex = /^([0-9a-fA-F:]+)\/(\d{1,3})$/;
            if (!cidrRegex.test(cidr)) {
                throw new Error("Invalid IPv6 CIDR format. Example: 2001:db8::/32");
            }

            const [ip, prefix] = cidr.split('/');
            const prefixLength = parseInt(prefix);
            
            if (prefixLength < 0 || prefixLength > 128) {
                throw new Error("Prefix length must be between 0 and 128");
            }

            try {
                // Normalize the IPv6 address
                const normalizedIP = normalizeIPv6(ip);
                const networkAddress = calculateIPv6NetworkAddress(normalizedIP, prefixLength);
                const lastAddress = calculateIPv6LastAddress(networkAddress, prefixLength);
                
                const firstUsable = incrementIPv6(networkAddress);
                const lastUsable = decrementIPv6(lastAddress);
                const numAddresses = calculateIPv6AddressCount(prefixLength);
                const netmask = calculateIPv6Netmask(prefixLength);

                return {
                    netmask,
                    numAddresses,
                    firstUsable,
                    lastUsable,
                    networkAddress,
                    lastAddress
                };
            } catch (e) {
                throw new Error("Invalid IPv6 address");
            }
        }

        function normalizeIPv6(ip) {
            // Expand shortened IPv6 addresses
            if (ip.includes('::')) {
                const parts = ip.split('::');
                const left = parts[0].split(':').filter(p => p);
                const right = parts[1].split(':').filter(p => p);
                const missing = 8 - (left.length + right.length);
                
                const expanded = left.concat(Array(missing).fill('0')).concat(right);
                return expanded.join(':');
            }
            return ip;
        }

        function calculateIPv6NetworkAddress(ip, prefixLength) {
            const ipParts = expandIPv6(ip);
            const networkParts = [];
            
            for (let i = 0; i < 8; i++) {
                const bitsInPart = Math.min(16, prefixLength - (i * 16));
                if (bitsInPart <= 0) {
                    networkParts.push(0);
                } else {
                    const partValue = parseInt(ipParts[i], 16);
                    const mask = 0xffff << (16 - bitsInPart);
                    networkParts.push(partValue & mask);
                }
            }
            
            return networkParts.map(p => p.toString(16)).join(':');
        }

        function calculateIPv6LastAddress(networkAddress, prefixLength) {
            const networkParts = expandIPv6(networkAddress);
            const lastParts = [];
            
            for (let i = 0; i < 8; i++) {
                const bitsInPart = Math.min(16, prefixLength - (i * 16));
                if (bitsInPart <= 0) {
                    lastParts.push(0xffff);
                } else {
                    const partValue = parseInt(networkParts[i], 16);
                    const hostBits = 16 - bitsInPart;
                    lastParts.push(partValue | ((1 << hostBits) - 1));
                }
            }
            
            return lastParts.map(p => p.toString(16)).join(':');
        }

        function calculateIPv6Netmask(prefixLength) {
            const maskParts = [];
            for (let i = 0; i < 8; i++) {
                const bitsInPart = Math.min(16, prefixLength - (i * 16));
                if (bitsInPart <= 0) {
                    maskParts.push('0000');
                } else {
                    const mask = 0xffff << (16 - bitsInPart);
                    maskParts.push(mask.toString(16).padStart(4, '0'));
                }
            }
            return maskParts.join(':');
        }

        function calculateIPv6AddressCount(prefixLength) {
            return BigInt(1) << BigInt(128 - prefixLength);
        }

        function expandIPv6(ip) {
            return ip.split(':').map(part => {
                if (part === '') return '0';
                return part.padStart(4, '0');
            });
        }

        function getRandomIPv6(networkInfo) {
            const startParts = expandIPv6(networkInfo.networkAddress).map(p => BigInt('0x' + p));
            const endParts = expandIPv6(networkInfo.lastAddress).map(p => BigInt('0x' + p));
            
            // Generate random parts
            const randomParts = [];
            for (let i = 0; i < 8; i++) {
                const range = endParts[i] - startParts[i];
                const random = BigInt(Math.floor(Math.random() * Number(range))) + startParts[i] + (i === 7 ? BigInt(1) : BigInt(0));
                randomParts.push(random.toString(16));
            }
            
            // Format as IPv6 (compress zeros)
            return compressIPv6(randomParts.join(':'));
        }

        function compressIPv6(ip) {
            // Replace the longest sequence of zeros with ::
            const parts = ip.split(':');
            
            let maxZeroStart = -1;
            let maxZeroLength = 0;
            let currentZeroStart = -1;
            let currentZeroLength = 0;
            
            for (let i = 0; i < parts.length; i++) {
                if (parts[i] === '0') {
                    if (currentZeroStart === -1) {
                        currentZeroStart = i;
                    }
                    currentZeroLength++;
                } else {
                    if (currentZeroLength > maxZeroLength) {
                        maxZeroLength = currentZeroLength;
                        maxZeroStart = currentZeroStart;
                    }
                    currentZeroStart = -1;
                    currentZeroLength = 0;
                }
            }
            
            if (currentZeroLength > maxZeroLength) {
                maxZeroLength = currentZeroLength;
                maxZeroStart = currentZeroStart;
            }
            
            if (maxZeroLength > 1) {
                const before = parts.slice(0, maxZeroStart).join(':');
                const after = parts.slice(maxZeroStart + maxZeroLength).join(':');
                return (before + '::' + after).replace(/^:|:$/g, '');
            }
            
            return ip;
        }

        function incrementIPv6(ip) {
            const parts = expandIPv6(ip);
            let carry = 1;
            
            for (let i = 7; i >= 0 && carry > 0; i--) {
                const part = parseInt(parts[i], 16) + carry;
                carry = part > 0xffff ? 1 : 0;
                parts[i] = (part & 0xffff).toString(16);
            }
            
            return compressIPv6(parts.join(':'));
        }

        function decrementIPv6(ip) {
            const parts = expandIPv6(ip);
            let borrow = 1;
            
            for (let i = 7; i >= 0 && borrow > 0; i--) {
                const part = parseInt(parts[i], 16) - borrow;
                borrow = part < 0 ? 1 : 0;
                parts[i] = (part & 0xffff).toString(16);
            }
            
            return compressIPv6(parts.join(':'));
        }

        // Utility Functions
        function showError(message) {
            const errorBox = document.getElementById('error-box');
            document.getElementById('error-message').textContent = message;
            errorBox.style.display = 'block';
        }

        function formatLargeNumber(num) {
            if (typeof num === 'bigint') {
                if (num < BigInt(1000)) return num.toString();
                if (num < BigInt(1e6)) return (Number(num) / 1e3).toFixed(1) + 'K';
                if (num < BigInt(1e9)) return (Number(num) / 1e6).toFixed(1) + 'M';
                if (num < BigInt(1e12)) return (Number(num) / 1e9).toFixed(1) + 'B';
                if (num < BigInt(1e15)) return (Number(num) / 1e12).toFixed(1) + 'T';
                if (num < BigInt(1e18)) return (Number(num) / 1e15).toFixed(1) + 'Q';
                return num.toString();
            } else {
                if (num < 1000) return num.toLocaleString();
                if (num < 1e6) return (num / 1e3).toFixed(1) + 'K';
                if (num < 1e9) return (num / 1e6).toFixed(1) + 'M';
                if (num < 1e12) return (num / 1e9).toFixed(1) + 'B';
                if (num < 1e15) return (num / 1e12).toFixed(1) + 'T';
                if (num < 1e18) return (num / 1e15).toFixed(1) + 'Q';
                return num.toExponential(2);
            }
        }
    </script>
</body>
</html>
